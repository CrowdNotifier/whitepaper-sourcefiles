\section{Identity-based encryption}

In this appendix we specify the specific identity-based encryption scheme used
by \name. In particular, \name uses a slight modification of the FullIdent Boneh-Franklin scheme~\cite{BonehF01} given by the following algorithms. (The only modification is that the randomness $r$ now also depends on the identity $\id$, which is passed to $\ibedec$ for verification purposes.)
\begin{itemize}
\item $\pp \gets \ibecommonsetup(1^\secpar)$. On input of security parameter $\secpar$, generate a type III set of bilinear groups $\group_1, \group_2, \group_T$ generated by respectively $\generator_1, \generator_2, \generator_T$ all of prime order $\grouporder$ and let $\pairsym: \group_1 \times \group_2 \to \group_T$ be the corresponding pairing. Generate the following hash-functions (modeled as random oracles): $\hash_1: \{0,1\}^* \to \group_1^*$ a hash function mapping points to the group $\group_1^*$, $\hash_T : \group_T \to \{0,1\}^{2\secpar}$ mapping group elements from the target group, $\hash_3: \{0,1\}^{2\secpar} \times \bins \times \bins \to \{0,1\}^{2\secpar}$, and $\hash_4: \{0,1\}^{2\secpar} \to \mathcal{K}$ mapping into the key-space of the authenticated encryption scheme.
  Setup outputs $\pp = ((\group_1, \group_2, \group_T, \generator_1, \generator_2, \generator_T, \grouporder, \pairsym), \hash_1, \hash_T, \hash_3, \hash_4)$.
\item $(\masterpk, \mastersk) \gets \ibekeygen(\pp)$. Pick random $\mastersk \gets \Zp$ and set $\masterpk = g_2^{\mastersk} \in \group_2.$ Return $(\masterpk, \mastersk)$.
  \item $\skid \gets \ibekeyder(\masterpk, \mastersk, \id)$. On input of a master public key $\masterpk$, a master private key $\mastersk$, and an identity $\id \in \{0, 1\}^*$; outputs private key $\skid = \hash_1(\id)^{\mastersk} \in \group_1$.
  \item $\ctxt \gets \ibeenc(\masterpk, \id, m)$. On input of a master public key $\masterpk$, an identity $\id \in \bins$, and a message $m$, proceed as follows. Check that $\masterpk \in \group_2^*$. Pick a random key $x \gets \{0, 1\}^{2\secpar}$ and compute
    \begin{align*}
      c_1 &= g_2^r, \\
      c_2 &= x \oplus \hash_T( \pairsym(\hash_1(\id), \masterpk)^r), \\
      c_3 &= \aeenc(H_4(x), m)
    \end{align*}
    where $r = \hash_3(x, m, \id)$. Return $\ctxt = (c_1, c_2, c_3)$.
  \item $m \gets \ibedec(\id, \skid, \ctxt)$. On input of an identity $\id$, a private key $\skid$, and a ciphertext $\ctxt$, proceed as follows. Parse $\ctxt$ as $(c_1, c_2, c_3)$ and return $\bot$ if parsing fails. Check that $\skid \in \group_1^*$, and compute $x' = c_2 \oplus \hash_T( \pairsym(\skid, c_1) )$ and $m' = \aedec(H_4(x'), c_3)$. Return $\bot$ if $m' = \bot$. Finally, compute $r' = \hash_3(x', m', \id)$ and check that $c_1 = g_2^{r'}$. If this check fails, return $\bot$, otherwise, return $m'$.
\end{itemize}